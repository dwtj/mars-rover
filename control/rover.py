import sys
import math

import numpy as np
import scipy
from scipy.interpolate import LSQUnivariateSpline

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.patches import Wedge, Circle

import sentinel
import sensors
import ir
import oi
import sonar
import servo
from codes import OIStopID


DEFAULT_CALIBRATION_DATA_DIR = 'calibrate/data/default'


zorders = {
    'breadcrumbs': 0,
    
    'bumps': 1,
    'cliffs': 2,
    'drops': 3,
    'tape': 4,
    
    'scan_field': 5,
    'scan_data': 6,
    
    'contours': 7
}


class Environment():
    """ Rover presents a to the user the `env` map, which depicts those
    elements of the environment which it has discovered. """

    def __init__(self):
        # Distance scan and event data is mapped onto the cartesian space
        # defined w.r.t. the robot's initial orientation. So the robot's
        # initial orientation in the real world is always represented as being
        # at the origin and as directed upward. To be clear, `_loc` is meant
        # to be the position of the centerpoint of the servo tower (not the
        # iRobot create's centerpoint.
        self._loc = (0.0, 0.0)
        self._direction = 90.0

        # The axis onto which the environment is plotted:
        self.view = plt.figure().add_subplot(111, aspect='equal')
        self.view.set_xlim(-300, 300)
        self.view.set_ylim(-300, 300)

        # A list of places in the `view` where the rover has previously
        # stopped. These are patch objects which have been added to the `view`.
        self.breadcrumbs = []

        # The dangers that the rover has found so far. These are lists of
        # patch objects which have been added to the `view`
        self.bumps = []
        self.cliffs = []
        self.drops = []
        self.tape = []

        # Point observations found in scans and mapped to `env` space.
        # In particular, these are `collection` objects which have been added
        # to the `view`.
        self.ir_obs = []
        self.sonar_obs = []

        # Objects discovered and plotted.
        self.objects = []

        # A semi-circle `Wedge` object that indicates the rover's current
        # location and direction:
        self.scan_field = None
        self.update_scan_field()
        self.draw()



    

    def __del__(self):
        plt.close(self.view.figure)




    def loc(self, new_loc = None):
        """ Gets the current location, a 2-tuple of xy-coordinates, if there is
        no `new_loc` argument. Otherwise, sets `new_loc` as the current
        location and re-draws the plot. """

        if new_loc == None:
            return self._loc
        else:
            self._loc = new_loc
            self.update_scan_field()
            self.draw()




    def move(self, dist):
        """ Updates the rover's location in the Environment by translating its
        position forward by the given `dist`. """
        
        self.add_breadcrumb()
        new_loc = self.conv_radial(90, dist)
        self.loc(new_loc)




    def direction(self, new_direction = None):
        """ If there is no `new_direction` argument, the current location,
        represented as a 2-tuple of xy-coordinates, is returned. Otherwise,
        sets the given 2-tuple, `new_direction`, as the current direction and
        re-draws the plot.
        """
        if new_direction == None:
            return self._direction
        else:
            self._direction = new_direction
            self.update_scan_field()
            self.draw()
        # TODO: normalize `_direction` to (-180.0, 180.0] or [0.0, 360.0)




    def rotate(self, delta):
        """ Updates rover's orientation in the Environment by rotating by given
        number of degrees. Rotation is CCW if `delta` is positive and CW if
        `delta` is negative. The location of the rover's servo tower is updated
        as well.  """

        r = 7.5  # Centimeters from rover's centerpoint to the servo centerpoint.
        x, y = self._loc
        theta = self._direction

        xprime = x + r * (np.cos(theta + delta) - np.cos(theta))
        yprime = y + r * (np.sin(theta + delta) - np.sin(theta))

        self.loc((xprime, yprime))
        self.direction(self._direction + delta)




    def add_scan(self, scan_data):
        """ Adds the given `scan` data (expected to have been generated by
        `rover.scan()`) to the environment and updates the plot. """

        ir_data, sonar_data = scan_data

        # Convert from radial to cartesian coordinates.
        ir_data = self.conv_radial_arr(ir_data[:, 0], ir_data[:, 1])
        sonar_data = self.conv_radial_arr(sonar_data[:, 0], sonar_data[:, 1])
        
        # Notice that IR points are drawn slightly larger than sonar points.

        col = self.view.scatter(ir_data[:, 0], ir_data[:, 1], s = 8)
        col.set_edgecolor('none')
        col.set_facecolor('blue')
        col.set_zorder(zorders['scan_data'])
        self.ir_obs(append(col))
        
        col = self.view.scatter(sonar_data[:, 0], sonar_data[:, 1], s = 7)
        col.set_edgecolor('none')
        col.set_facecolor('green')
        col.set_zorder(zorders['scan_data'])
        self.sonar_obs(append(col))
        
        self.draw()




    def clear_scans(self):
        """ Removes all of the points collections that have been added to the
        `Environment`. """

        for col in self.ir_obs:
            col.remove()

        for col in self.sonar_obs:
            col.remove()

        self.draw()




    def add_object(r, theta, obj_radius):
        """ Adds an object at the given location. This location is given as a
        radial measure w.r.t. the object's current location. """

        c = Circle(self.conv_radial(r, theta), obj_radius)
        self.objects.append(c)




    def add_breadcrumb(self):
        """ Adds a breadcrumb """
        c = Circle(self._loc, radius = 16.25)
        c.set_facecolor('0.65')  # grey
        c.set_edgecolor('black')
        c.set_zorder(zorders['breadcrumbs'])
        c.set_fill(True)
        self.view.add_artist(c)
        self.breadcrumbs.append(c)
        self.draw()




    def add_danger(self, danger_id):
        """ Appends a new danger to the appropriate list of `env`, and updates
        the `env` view. The position at which the danger is placed is computed
        based on the rover's location and direction, but also where on the
        robot that particular danger-detection sensor is located. """
        
        """if danger_id == left_bumper:
            
        elif danger_id == right_bumper:
            
        elif danger_id == left_and_right_bumper:

        elif danger_id == front_left_cliff:

        elif danger_id == front_right_cliff:

        elif danger_id == left_cliff:

        elif danger_id == right_cliff:

        elif danger_id == white_tape_front_left:

        elif danger_id == white_tape_front_right:

        elif danger_id == white_tape_left:

        elif danger_id == white_tape_right:

        elif danger_id == left_wheel:

        elif danger_id == right_wheel:

        elif danger_id == middle_wheel:

        else:
            raise NotImplementedError()
        """


        # Find the danger location using `danger_angle` and `danger_distance`
        # TODO: maybe later
        # danger_loc = conv_radial(self, danger_theta, danger_r)

        # Plot
        if (1 <= danger_id <= 3): # Bumper range in OIStopID
            """ Adds a bump """
            c = Circle(self._loc, radius = 6.25)
            c.set_facecolor('0.65')  # grey
            c.set_edgecolor('black')
            c.set_zorder(zorders['bumps'])
            c.set_fill(True)
            self.view.add_artist(c)
            self.bumps.append(c)
            self.draw()
        elif (4 <= danger_id <= 7): # Cliff range in OIStopID
            """ Adds a cliff """
            c = Circle(self._loc, radius = 6.25)
            c.set_facecolor('0.65')  # grey
            c.set_edgecolor('black')
            c.set_zorder(zorders['cliffs'])
            c.set_fill(True)
            self.view.add_artist(c)
            self.cliffs.append(c)
            self.draw()
        elif (12 <= danger_id <= 14): # Drop range in OIStopID
            """ Adds a drop """
            c = Circle(self._loc, radius = 6.25)
            c.set_facecolor('0.65')  # grey
            c.set_edgecolor('black')
            c.set_zorder(zorders['drops'])
            c.set_fill(True)
            self.view.add_artist(c)
            self.drops.append(c)
            self.draw()
        elif (8 <= danger_id <= 11): # White tape range in OIStopID
            """ Adds tape """
            c = Circle(self._loc, radius = 6.25)
            c.set_facecolor('0.65')  # grey
            c.set_edgecolor('black')
            c.set_zorder(zorders['tape'])
            c.set_fill(True)
            self.view.add_artist(c)
            self.tape.append(c)
            self.draw()
        else:
            raise NotImplementedError()
            
        # The following is the temporary workaround:
        sys.stderr.write("danger found: " + str(danger_id)) # TODO: check to see if enum strig is a thing




    def update_scan_field(self):
        """ Updates the location of the `scan_field` semi-circle displayed to
        indicate its location and the direction in which it is facing. If there
        was a no previous scan field, then will be added. Should be called
        whenever either location or needs to be
        called as part of the rover's move and rotate functions.) """

        # Remove the old scan field, if there is one:
        w = self.scan_field
        if w != None:
            self.view.artists.remove(w)

        # Make a semi-circle with radius 100 at the current rover location:
        w = Wedge(self._loc, 100, self._direction - 90, self._direction + 90)
        w.set_facecolor('0.90')  # grey
        w.set_edgecolor('none')
        w.set_zorder(zorders['scan_field'])
        w.set_fill(True)

        self.view.add_artist(w)
        self.scan_field = w




    def set_bounds(self, xlim, ylim):
        """ Redraws the `env` plot with different boundaries. `xlim` and `ylim`
        are expected to be 2-tuples. """

        self.view.set_xlim(xlim[0], xlim[1])
        self.view.set_ylim(ylim[0], ylim[1])
        self.draw()




    def draw(self):
        """ Refreshes the view of the `env`. """
        self.view.relim()
        self.view.autoscale_view(True, True, True)
        self.view.figure.canvas.draw()
        self.view.figure.show()




    def conv_radial(self, r, theta):
        """ Uses the rover's current orientation in the environment (i.e. its
        current location and angle) to map a single radial point into the
        cartesian environment presented by `env` view. Returns a 2-tuple, whose
        first entry is the x location and whose second entry is the y location.
        """

        theta_prime = (theta - 90.0 + self._direction) * (np.pi / 180.0)
        return (r * np.cos(theta_prime) + self._loc[0],
                r * np.sin(theta_prime) + self._loc[1])




    def conv_radial_arr(self, rs, thetas):
        """ Uses the rover's current orientation in the environment (i.e. its
        current location and angle) to map these radial points into the
        cartesian environment presented by `env` view.

        `thetas` is an `np.ndarray` of angles (measured in degrees), and `rs` is
        a `np.ndarray` of the corresponding radial distances.

        A newly created `np.ndarray` with two columns returned. For each
        (theta, r) pair in the inputs, a single (x, y) coordinate will be in
        this returned array.
        """

        # TODO: reimplement this using `radial_to_env()` as a numpy `ufunc`.

        if len(thetas) != len(rs):
            raise ValueError("`thetas` and `rs` must be of the same length.")

        # Make the given angles w.r.t. the 0 degrees of the `env`, convert
        # them to radians, and make a copy them to the other column:
        rv = np.empty((len(rs), 2), dtype = np.float64)
        rv[:, 0] = thetas - 90.0 + self._direction
        rv[:, 0] *= np.pi / 180.0
        rv[:, 1] = rv[:, 0]

        # Find the `x` and `y` values w.r.t. the origin of `env`:
        rv[:, 0] = rs * np.cos(rv[:, 0]) + self._loc[0]
        rv[:, 1] = rs * np.sin(rv[:, 1]) + self._loc[1]

        return rv









class Scanner():
    """ Displays a radial view of the immediate surroundings as generated by
    ir and servo radial distance data from a particular orientation. """

    def __init__(self):
        # A list of 2-tuples generated by rover.scan():
        self.scans = []

        # A list of contours to be draw on the current scan:
        self.contours = []

        # Startup the axis to be used for displaying scan data:
        self.view = plt.figure().add_subplot(111, projection = 'polar')
        self.draw()



    def __del__(self):
        plt.close(self.view.figure)



    def add_scan(self, scan_data):
        """ TODO
        """
        self.scans.append(scan_data)
        
        ''' DEBUG: drawing onto the scanner has been disabled
        ir_data, sonar_data = scan_data
        
        angles = ir_data[:, 0] * (np.pi / 180.0)
        rs = ir_data[:, 1]
        self.view.scatter(angles, rs, 'g')

        angles = sonar_data[:, 0] * (np.pi / 180.0)
        rs = sonar_data[:, 1]
        rs = rs[~np.isnan(rs)]
        self.view.scatter(angles, rs, 'b')
        '''

        #self.draw()



    def clear_scans(self):
        self.scans.clear()




    def find_obj_clouds(self):
        """ Finds data from each distinct object generated across all scans.
        """

        comb_scans = ()
        
        if len(self.scans) < 1:
            # There aren't any scans
            raise NotImplementedError()
        
        comb_scans = self.scans[0][0], self.scans[0][1]
        
        # Iterate through all scans
        for i in range(1, len(self.scans)):
            comb_scans = np.append(comb_scans[0], self.scans[i][0], axis=0), np.append(comb_scans[1], self.scans[i][1], axis=0)

        # Sort each ndarray
        comb_scans = np.sort(comb_scans[0], axis=0), np.sort(comb_scans[1], axis=0)
        
        # Create list of objects. 
        # This should be a 2-tuple containing all scans with data points
        # sorted. The first element should be a two column ndarray
        # containing angles and their corresponding distances for IR.
        # The second is the same, but for sonar. 
        obj_list = []
        
        # Iterate through consolidated scans to find clumps of objects
        min_width = 3 # minimum degrees for an object to be recognized
        
        prev_angle = comb_scans[0][0][0]
        start = 0 # start index for the current object

        # Go through all IR data
        for i in range(0, len(comb_scans[0])):
            # If the reading is nan for IR, throw it out.
            if math.isnan(comb_scans[0][i][1]):
                comb_scans = np.delete(comb_scans[0],i,0), np.delete(comb_scans[1],i,0)
            
            # Check for jumps in the non-NaN data, indicating a new object.
            if comb_scans[0][i][0] - prev_angle > 1:
                obj = comb_scans[0][start:i], comb_scans[1][start:i]
                start = i
                obj_list.append(obj)

            prev_angle = comb_scans[0][i][0]
        
        return obj_list




    def draw(self):
        pass
        """ DEBUG: drawing of the scanner has been disabled
        self.view.set_rmax(100)
        self.view.figure.canvas.draw()
        self.view.figure.show()
        """









class Rover():
    """ TODO
    """

    def __init__(self, sen = None, calib_dir = None, debug = False):
        """ TODO
        """
        if debug == True:
            sen = "DEBUG"
        elif sen is None:
            sen = sentinel.Sentinel()
        elif type(sen) is str:
            sen = sentinel.Sentinel(sen)
        elif type(sen) != sentinel.Sentinel:
            raise TypeError("The argument `sen` must be `None`, of type `str` "
                                                       "or of type `Sentinel`")
        self.sen = sen

        # Attempt to load the converters from `calib_dir`:
        if calib_dir == None:
            calib_dir = DEFAULT_CALIBRATION_DATA_DIR

        self.ir_conv = sensors.gen_ir_converter(calib_dir + "/ir.csv")
        self.sonar_conv = sensors.gen_sonar_converter(calib_dir + "/sonar.csv")
        self.servo_conv = sensors.gen_servo_converter(calib_dir + "/servo.csv")
        # TODO: implement move_conv
        # TODO: implement rotate_conv

        self.env = Environment()
        self.scanner = Scanner()



    def __del__(self):
        del(self.env)
        del(self.scanner)




    def scan(self, start=0, end=180, updt_scan=True, updt_env=True):
        """ This calls `sensors.scan()` to receive raw data from the robot and
        converts the resulting distances using the current `ir_conv` and
        `sonar_conv`.

        This data will be collected as the servo makes a single pass from the
        `start` angle to the `end` angle. Note that both are assumed to be
        integers and measured in degrees.

        The return value is a 2-tuple, where both elements are an
        `np.ndarray` object. The first element of the pair is the ir data 
        generated by a scan, while the second element is the sonar data. Both
        arrays have angles (measured in degrees) in their first column and
        corresponding radial distances (measured in in cm) in the second
        column. The `Rover` object's converters have been used in generating
        this data.

        If and only if `updt_scan` is true, will the results be automatically
        passed to the current `Scanner` object. Similarly, if and only if
        `updt_env` is true will the results be automatically passed to the
        current `Environment` object. If and only if both of these arguments
        are false will the results be returned to the user.

        Note that the scan can happen in either direction (i.e. clockwise or
        counter-clockwise) depending on which angle is bigger than the other.
        """

        # Generate a pulse width for each angle:
        if start <= end:
            angles = np.array([i for i in range(start, end + 1)],
                                                 dtype = np.float64)
        else:
            angles = nd.array([i for i in range(start, end - 1, -1)],
                                                 dtype = np.float64)

        pulse_widths = self.servo_conv(angles)

        # Perform the scan, then return the servo to 90 degrees.
        ir_data, sonar_data = sensors.scan(self.sen, pulse_widths)
        servo.pulse_width(self.sen, self.servo_conv(90.0))

        # Perform the conversion from raw readings to distances.
        ir_data[:] = self.ir_conv(ir_data[:])
        sonar_data[:] = self.sonar_conv(sonar_data[:])

        # Construct the return value by adding the angle columns:
        rv = (np.empty((len(ir_data), 2)), np.empty((len(sonar_data), 2)))
        rv[0][:, 1] = ir_data
        rv[1][:, 1] = sonar_data
        for idx, a in enumerate(angles):
            offset = idx * 5
            rv[0][offset: offset + 5, 0] = a
            rv[1][offset: offset + 5, 0] = a
        
        # Report findings to relevant authorities.
        if updt_scan == False and updt_env == False:
            return rv
        if updt_scan == True:
            self.scanner.add_scan(rv)
        if updt_env == True:
            self.env.add_scan(rv)




    def move(self, dist = 300, speed = 90):
        """ Moves the rover, adds a breadcrumb, updates the rovers location in
        `env`, and adds to `env` any dangers that were found. """

        self.gen_objects()

        # TODO: use move_conv to correct for rover sensor error.
        dist, stop_reason = oi.move(self.sen, dist, speed)
        self.env.move(dist)

        if stop_reason != OIStopID.full_distance:
            self.env.add_danger(stop_reason)




    def rotate(self, delta):
        """ Sends a command to the `rover` to rotate by the given angle
        (measured in degrees), and updates the rover's current direction.
        This will convert scan data into objects. """

        self.gen_objects()

        # TODO: use `rotate_conv` to correct for rover sensor error.
        oi.rotate(self.sen, delta)
        self.env.rotate(delta)
        
        
        
    def servo_angle(self, angles):
        """ Sends a command to the rover to turn the servo to the given angle.
        The pulse width which is sent is determined via the calibrated
        `servo_conv`. """
        servo.pulse_width(self.sen, self.servo_conv(angles))




    def gen_objects(self):
        """ Takes the scan data displayed as a scatter-plot points, analyzes
        them, generates object locations, and plots these in `env`. The
        scan data points are also removed from the `env`. """

        # Add an object for each cloud found to `env`.
        for cloud in self.scanner.find_obj_clouds():

            ir_data, sonar_data = cloud
            ir_angles = ir_data[:, 0]
            bounds = (min(ir_angles), max(ir_angles))

            angular_mean = np.mean([np.mean(ir_data[:, 0]),
                                    np.mean(sonar_data[:, 0])]
            radial_mean = np.mean([np.mean(ir_data[:, 1]),
                                   np.mean(sonar_data[:, 1])]

            # TODO: plot using better measure of radius.
            radius = (bounds[1] - bounds[0]) / 2.0

            self.env.add_object(angular_mean, radial_mean, radius)

        self.env.clear_scans()
        self.scanner.clear_scans()
        self.env.draw()
